<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>TopoSort 3D Viewer</title>
  <style>
    body { margin: 0; font-family: Arial, sans-serif; display: flex; height: 100vh; }
    #controls { width: 360px; padding: 12px; background: #0f172a; color: #e2e8f0; box-sizing: border-box; overflow-y: auto; }
    #viewer { flex: 1; }
    textarea { width: 100%; box-sizing: border-box; }
    button { margin-top: 8px; padding: 8px 12px; cursor: pointer; }
    .hint { font-size: 12px; color: #94a3b8; }
    .row { margin-top: 8px; display: flex; gap: 6px; flex-wrap: wrap; }
    #status { font-size: 12px; color: #cbd5e1; margin-top: 6px; }
    .section { margin-bottom: 12px; padding: 8px; border: 1px solid #1f2937; border-radius: 6px; background: #111827; }
    .section h4 { margin: 0 0 6px 0; font-size: 14px; }
    select, input[type="number"] { padding: 6px; }
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js",
      "three/examples/jsm/controls/OrbitControls.js": "https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/controls/OrbitControls.js"
    }
  }
  </script>
</head>
<body>
  <div id="controls">
    <h3>TopoSort 3D/VR Preview</h3>

    <div class="section">
      <h4>图数据输入</h4>
      <div class="row">
        <label style="font-size:12px;color:#94a3b8;">输入类型：</label>
        <select id="inputType">
          <option value="edge">普通图（边列表）</option>
          <option value="csr">紧缩图（CSR）</option>
        </select>
      </div>
      <p class="hint">格式：普通图为第一行 n m，后续 m 行 u v；紧缩图为 n m，随后 h[0..n] 与 list。</p>
      <textarea id="graphInput" rows="6" placeholder="6 6&#10;0 1&#10;0 2&#10;1 3&#10;2 3&#10;3 4&#10;4 5"></textarea>
      <div class="row">
        <button id="confirmBtn">确认输入</button>
        <button id="genSmall">小规模</button>
        <button id="genMedium">中规模</button>
        <button id="genLarge">大规模</button>
      </div>
      <div class="row">
        <button id="genEdge">生成普通图</button>
        <button id="genCSR">生成紧缩图</button>
      </div>
      <p class="hint">转换结果（只读）：</p>
      <textarea id="convertedOutput" rows="5" readonly placeholder="h: 0 0 1 ...&#10;list: ..."></textarea>
    </div>

    <div class="section">
      <h4>布局加载 / 播放</h4>
      <p class="hint">粘贴 CLI 输出的 JSON（包含 layout/topo）。</p>
      <textarea id="jsonInput" rows="6" placeholder='{"layout":[{"id":0,"x":0,"y":0,"z":0,"layer":0}]}'></textarea>
      <button id="loadBtn">Load Layout</button>
      <button id="startVizBtn">开始可视化</button>
      <p class="hint">Use mouse to rotate/zoom. Layers are mapped to depth (z axis).</p>
      <div class="row">
        <button id="playBtn">Play</button>
        <button id="pauseBtn">Pause</button>
        <button id="resetBtn">Reset</button>
      </div>
      <div class="row">
        <label style="font-size:12px;color:#94a3b8;">Step(ms): <input id="stepMs" type="number" value="800" style="width:60px;" /></label>
      </div>
      <div id="status">Status: idle</div>
    </div>
  </div>
  <div id="viewer"></div>
  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";

    // ---------- Graph parsing + validation (frontend bridge) ----------
    function parseInts(text) {
      const tokens = text.trim().split(/\s+/).filter(t => t.length);
      const nums = tokens.map(t => Number(t));
      if (nums.some(v => Number.isNaN(v))) throw new Error("输入包含非数字字符");
      return nums;
    }

    function buildCSRFromAdj(adj) {
      const n = adj.length;
      const h = new Array(n + 1).fill(0);
      for (let i = 0; i < n; ++i) h[i + 1] = h[i] + adj[i].length;
      const list = new Array(h[n]);
      let p = 0;
      for (let u = 0; u < n; ++u) {
        for (const v of adj[u]) list[p++] = v;
      }
      return { h, list };
    }

    function validateDAG(adj) {
      const n = adj.length;
      const indeg = new Array(n).fill(0);
      for (let u = 0; u < n; ++u) for (const v of adj[u]) indeg[v]++;
      const q = [];
      for (let i = 0; i < n; ++i) if (indeg[i] === 0) q.push(i);
      let head = 0;
      while (head < q.length) {
        const u = q[head++];
        for (const v of adj[u]) {
          indeg[v]--;
          if (indeg[v] === 0) q.push(v);
        }
      }
      return q.length !== n;
    }

    function computeTopo(adj) {
      const n = adj.length;
      const indeg = new Array(n).fill(0);
      for (let u = 0; u < n; ++u) for (const v of adj[u]) indeg[v]++;
      const q = [];
      for (let i = 0; i < n; ++i) if (indeg[i] === 0) q.push(i);
      const topo = [];
      let head = 0;
      while (head < q.length) {
        const u = q[head++];
        topo.push(u);
        for (const v of adj[u]) {
          indeg[v]--;
          if (indeg[v] === 0) q.push(v);
        }
      }
      if (topo.length !== n) throw new Error("生成的图出现环，无法拓扑排序");
      return topo;
    }

    // ---------- Graph generator ----------
    const SIZE_PRESETS = {
      small: { min: 5, max: 10, pRange: [0.22, 0.42] },
      medium: { min: 15, max: 30, pRange: [0.12, 0.25] },
      large: { min: 50, max: 80, pRange: [0.05, 0.12] },
    };

    let currentSize = 'small';

    function randInt(min, maxInclusive) {
      return Math.floor(Math.random() * (maxInclusive - min + 1)) + min;
    }

    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; --i) {
        const j = randInt(0, i);
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
    }

    function sampleProb(preset) {
      const [a, b] = preset.pRange;
      return Math.random() * (b - a) + a;
    }

    function generateDagRaw(preset) {
      const n = randInt(preset.min, preset.max);
      const order = Array.from({ length: n }, (_, i) => i);
      shuffle(order);
      const adjSet = Array.from({ length: n }, () => new Set());

      // Ensure connectivity with a chain along the topo order.
      for (let i = 0; i + 1 < n; ++i) adjSet[order[i]].add(order[i + 1]);

      // Vary density by distance; nearer nodes get slightly higher chance.
      const baseP = sampleProb(preset);
      for (let i = 0; i < n; ++i) {
        for (let j = i + 1; j < n; ++j) {
          const dist = j - i;
          const scale = Math.exp(-dist / (n * 0.12));
          const p = baseP * (0.6 + 0.8 * scale);
          if (Math.random() < p) adjSet[order[i]].add(order[j]);
        }
      }

      // Optional shortcut sprinkling with a lower probability.
      const shortcutP = baseP * 0.4;
      for (let i = 0; i + 2 < n; ++i) {
        if (Math.random() < shortcutP) {
          const u = order[i];
          const v = order[randInt(i + 2, n - 1)];
          adjSet[u].add(v);
        }
      }

      const adj = adjSet.map(s => Array.from(s).sort((a, b) => a - b));
      const { h, list } = buildCSRFromAdj(adj);
      const m = list.length;
      return { n, m, adj, h, list };
    }

    function generateDag(presetKey) {
      const preset = SIZE_PRESETS[presetKey] || SIZE_PRESETS.small;
      const variants = randInt(2, 4);
      const cand = [];
      for (let i = 0; i < variants; ++i) cand.push(generateDagRaw(preset));
      return cand[randInt(0, cand.length - 1)];
    }

    function formatEdgeList(adj) {
      const n = adj.length;
      let m = 0;
      for (const lst of adj) m += lst.length;
      const lines = [`${n} ${m}`];
      for (let u = 0; u < n; ++u) {
        for (const v of adj[u]) lines.push(`${u} ${v}`);
      }
      return lines.join('\n');
    }

    function parseEdgeList(text) {
      const nums = parseInts(text);
      if (nums.length < 2) throw new Error("缺少 n m");
      const n = nums[0];
      const m = nums[1];
      if (n < 0 || m < 0) throw new Error("n 或 m 为负");
      const rest = nums.slice(2);
      if (rest.length !== m * 2) throw new Error("边数量与 m 不匹配");
      const adj = Array.from({ length: n }, () => []);
      for (let i = 0; i < m; ++i) {
        const u = rest[2 * i];
        const v = rest[2 * i + 1];
        if (u < 0 || v < 0 || u >= n || v >= n) throw new Error(`边越界: ${u}->${v}`);
        adj[u].push(v);
      }
      for (let u = 0; u < n; ++u) {
        adj[u] = Array.from(new Set(adj[u])).sort((a, b) => a - b);
      }
      const { h, list } = buildCSRFromAdj(adj);
      const hasCycle = validateDAG(adj);
      const mActual = list.length;
      return { n, m: mActual, adj, h, list, hasCycle };
    }

    function parseCSR(text) {
      const nums = parseInts(text);
      if (nums.length < 2) throw new Error("缺少 n m");
      const n = nums[0];
      const m = nums[1];
      if (n < 0 || m < 0) throw new Error("n 或 m 为负");
      if (nums.length < n + 2) throw new Error("缺少 h 数组");
      const h = nums.slice(2, 2 + n + 1);
      const list = nums.slice(2 + n + 1);
      if (h.length !== n + 1) throw new Error("h 长度不正确");
      if (h[0] !== 0) throw new Error("h[0] 必须为 0");
      for (let i = 0; i < n; ++i) if (h[i] > h[i + 1]) throw new Error("h 不是非递减的");
      if (h[n] !== list.length) throw new Error("h[n] 与 list 长度不一致");
      const adj = Array.from({ length: n }, () => []);
      for (let u = 0; u < n; ++u) {
        for (let idx = h[u]; idx < h[u + 1]; ++idx) {
          const v = list[idx];
          if (v < 0 || v >= n) throw new Error(`邻接点越界: ${u}->${v}`);
          adj[u].push(v);
        }
        adj[u] = Array.from(new Set(adj[u])).sort((a, b) => a - b);
      }
      const hasCycle = validateDAG(adj);
      const mActual = list.length;
      return { n, m: mActual, adj, h, list, hasCycle };
    }

    function formatCSR(n, m, h, list) {
      // Numeric-only lines to satisfy downstream parsing: first line n m, second line h + list.
      return `${n} ${m}\n${h.join(" ")} ${list.join(" ")}`;
    }

    function generateAndFill(format) {
      const presetKey = currentSize;
      const { n, m, adj, h, list } = generateDag(presetKey);
      const topo = computeTopo(adj);
      const layout = generateFallbackLayout(n, topo);
      const payload = { h, list, topo, steps: topo, layout, random: true };

      const graphInput = document.getElementById('graphInput');
      const convertedOutput = document.getElementById('convertedOutput');
      const inputType = document.getElementById('inputType');
      const jsonInput = document.getElementById('jsonInput');

      if (format === 'edge') {
        inputType.value = 'edge';
        graphInput.value = formatEdgeList(adj);
        // Show each edge on a new line in the converted preview.
        convertedOutput.value = formatEdgeList(adj);
      } else {
        inputType.value = 'csr';
        graphInput.value = formatCSR(n, m, h, list);
        // CSR preview with a line break between h and list.
        convertedOutput.value = formatCSR(n, m, h, list);
      }

      // Persist generated layout/topo into the visualization JSON box for one-click run.
      jsonInput.value = JSON.stringify(payload);
      document.lastH = h;
      document.lastList = list;
      edgeJitterEnabled = true; // enable edge jitter for generated graphs
    }

    function handleConfirmInput() {
      const type = document.getElementById('inputType').value;
      const text = document.getElementById('graphInput').value;
      const output = document.getElementById('convertedOutput');
      try {
        const parsed = type === 'edge' ? parseEdgeList(text) : parseCSR(text);
        if (parsed.hasCycle) {
          alert('数据不合法：图中存在环（需要 DAG）。');
          output.value = '';
          return;
        }
        output.value = formatCSR(parsed.n, parsed.m, parsed.h, parsed.list);
      } catch (e) {
        alert('输入错误：' + e.message);
        output.value = '';
      }
    }

    const CONTROLS_WIDTH = 360;
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth - CONTROLS_WIDTH, window.innerHeight);
    document.getElementById('viewer').appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xffffff);
    const camera = new THREE.PerspectiveCamera(60, (window.innerWidth-CONTROLS_WIDTH) / window.innerHeight, 0.1, 1000);
    camera.position.set(8, 8, 12);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 0, 0);

    const light = new THREE.DirectionalLight(0xffffff, 1.0);
    light.position.set(5, 10, 7);
    scene.add(light);
    scene.add(new THREE.AmbientLight(0x404040));

    let nodesGroup = new THREE.Group();
    let edgesGroup = new THREE.Group();
    scene.add(nodesGroup);
    scene.add(edgesGroup);

    const NODE_COLORS = [0x2563eb, 0xf59e0b, 0x10b981, 0xec4899, 0x8b5cf6, 0x22d3ee, 0xf97316, 0x14b8a6];
    const EDGE_ACTIVE = 0x000000;
    const EDGE_HIGHLIGHT = 0xff0000;
    const EDGE_REMOVED = 0xcccccc;

    let edgeJitterEnabled = false; // enable random edge length tweak for generated graphs

    let nodeMap = new Map(); // id -> mesh
    let edgeObjs = []; // {u,v,line,active:true}
    let adjIdx = [];  // per-u list of edge indices
    let topoOrder = [];
    let playTimer = null;
    let currentStep = 0;
    let indeg = [];
    let queue = [];
    let processedCount = 0;
    let highlighted = []; // edge indices currently in highlight

    function clearNodes() {
      scene.remove(nodesGroup);
      scene.remove(edgesGroup);
      nodesGroup = new THREE.Group();
      edgesGroup = new THREE.Group();
      scene.add(nodesGroup);
      scene.add(edgesGroup);
      nodeMap.clear();
      edgeObjs = [];
      adjIdx = [];
      topoOrder = [];
      currentStep = 0;
      indeg = [];
      queue = [];
      processedCount = 0;
      highlighted = [];
      if (playTimer) { clearInterval(playTimer); playTimer = null; }
      document.getElementById('status').textContent = 'Status: idle';
    }

    function buildIndeg(h, list) {
      const n = h.length - 1;
      indeg = new Array(n).fill(0);
      for (let u = 0; u < n; ++u) {
        for (let idx = h[u]; idx < h[u + 1]; ++idx) indeg[list[idx]]++;
      }
      queue = [];
      for (let i = 0; i < n; ++i) if (indeg[i] === 0) queue.push(i);
      processedCount = 0;
    }

    function generateFallbackLayout(n, topo) {
      const pts = [];
      if (!n) return pts;
      const order = topo && topo.length === n ? [...topo] : Array.from({ length: n }, (_, i) => i);
      shuffle(order);

      // Randomize layer ordering and loosen layer notion.
      const layerSize = Math.max(1, Math.floor(Math.sqrt(n)));
      const layers = [];
      for (let i = 0; i < Math.ceil(n / layerSize); ++i) layers.push(i);
      shuffle(layers);

      const baseTheta = Math.random() * Math.PI * 2;
      const radialBase = 1.5 + Math.random();
      for (let i = 0; i < n; ++i) {
        const layerIdx = Math.floor(i / layerSize);
        const layer = layers[layerIdx % layers.length];
        // Random angular placement
        const theta = baseTheta + Math.random() * Math.PI * 2;
        // Wide radius variation, only lightly influenced by layer
        const radius = radialBase + Math.random() * 2.5 + layer * (0.2 + Math.random() * 0.3);
        const jitterR = radius * (0.5 + Math.random());
        // Shuffle depth so layers are not strictly ordered
        const depthBase = -layer * (0.6 + Math.random() * 0.6);
        const jitterZ = (Math.random() - 0.5) * 1.8;
        const x = Math.cos(theta) * jitterR;
        const y = Math.sin(theta) * jitterR;
        const z = depthBase + jitterZ;
        pts.push({ id: order[i], x, y, z, layer });
      }
      return pts;
    }

    function makeArrow(pu, pv, color) {
      const dirBase = new THREE.Vector3().subVectors(pv, pu);
      let len = dirBase.length();
      if (len === 0) len = 0.001;
      let dir = dirBase.clone().normalize();

      // Keep arrows anchored to nodes; only apply small cosmetic variation to arrow head.
      const margin = Math.min(0.18, len * 0.25);
      len = Math.max(0.05, len - margin);
      let headLen = Math.min(0.35, Math.max(0.12, len * 0.2));
      let headWidth = 0.12;
      if (edgeJitterEnabled) {
        headLen *= 0.8 + Math.random() * 0.5;   // vary head size
        headWidth *= 0.7 + Math.random() * 0.6; // vary head width
      }

      const arrow = new THREE.ArrowHelper(dir, pu, len, color, headLen, headWidth);
      arrow.cone.material.transparent = true;
      arrow.line.material.transparent = true;
      return arrow;
    }

    function renderLayout(layout, h, list, topo) {
      clearNodes();
      const sphereGeo = new THREE.SphereGeometry(0.2, 16, 16);
      const baseColor = 0x94a3b8;

      let finalLayout = layout && layout.length ? layout : [];
      const inferredN = h && h.length ? h.length - 1 : (layout ? layout.length : 0);
      if (!finalLayout.length && inferredN > 0) {
        finalLayout = generateFallbackLayout(inferredN, topo);
      }

      const posMap = new Map();
      finalLayout.forEach(p => {
        posMap.set(p.id, new THREE.Vector3(p.x, p.y, p.z));
        const mat = new THREE.MeshStandardMaterial({ color: baseColor, transparent: true, opacity: 0.35, emissive: 0x000000 });
        const m = new THREE.Mesh(sphereGeo, mat);
        m.position.set(p.x, p.y, p.z);
        nodesGroup.add(m);
        nodeMap.set(p.id, m);
      });

      if (h && list && h.length > 1 && list.length > 0) {
        adjIdx = Array.from({ length: h.length - 1 }, () => []);
        for (let u = 0; u < h.length - 1; ++u) {
          for (let idx = h[u]; idx < h[u + 1]; ++idx) {
            const v = list[idx];
            const pu = posMap.get(u);
            const pv = posMap.get(v);
            if (pu && pv) {
              const arrow = makeArrow(pu, pv, EDGE_ACTIVE);
              edgesGroup.add(arrow);
              adjIdx[u].push(edgeObjs.length);
              edgeObjs.push({ u, v, line: arrow, active: true });
            }
          }
        }
      }

      topoOrder = topo || [];
      if (h && list && h.length > 1) buildIndeg(h, list);
      highlightStep(0, true);

      controls.update();
    }

    function highlightStep(step, reset = false) {
      if (reset) {
        nodeMap.forEach(mesh => { mesh.material.opacity = 0.35; mesh.material.emissive.set(0x000000); });
        edgeObjs.forEach(e => {
          const setColor = (c, op) => {
            if (e.line.line) { e.line.line.material.color.set(c); e.line.line.material.opacity = op; }
            if (e.line.cone) { e.line.cone.material.color.set(c); e.line.cone.material.opacity = op; }
          };
          if (e.active) setColor(EDGE_ACTIVE, 0.6); else setColor(EDGE_REMOVED, 0.08);
        });
        processedCount = 0;
        highlighted = [];
      }
      // optional initial highlight of first in queue
      if (queue.length) {
        resetHighlightsToBlack();
        highlightOutgoing(queue[0]);
      }
    }

    function resetHighlightsToBlack() {
      for (const ei of highlighted) {
        const e = edgeObjs[ei];
        if (e && e.active) {
          if (e.line.line) { e.line.line.material.color.set(EDGE_ACTIVE); e.line.line.material.opacity = 0.6; }
          if (e.line.cone) { e.line.cone.material.color.set(EDGE_ACTIVE); e.line.cone.material.opacity = 0.6; }
        }
      }
      highlighted = [];
    }

    function highlightOutgoing(u) {
      if (!adjIdx[u]) return;
      for (const ei of adjIdx[u]) {
        const e = edgeObjs[ei];
        if (e && e.active) {
          if (e.line.line) { e.line.line.material.color.set(EDGE_HIGHLIGHT); e.line.line.material.opacity = 0.9; }
          if (e.line.cone) { e.line.cone.material.color.set(EDGE_HIGHLIGHT); e.line.cone.material.opacity = 0.9; }
          highlighted.push(ei);
        }
      }
    }

    function processStep() {
      if (!queue.length) {
        document.getElementById('status').textContent = 'Status: done or stuck (no zero-indegree)';
        pausePlayback();
        return;
      }
      // Highlight next node's outgoing edges in red (preview)
      resetHighlightsToBlack();
      highlightOutgoing(queue[0]);

      const u = queue.shift();
      const mesh = nodeMap.get(u);
      if (mesh) {
        const c = NODE_COLORS[processedCount % NODE_COLORS.length];
        mesh.material.color.set(c);
        mesh.material.opacity = 1.0;
        mesh.material.emissive.set(0x000000);
      }

      if (adjIdx[u]) {
        for (const ei of adjIdx[u]) {
          const e = edgeObjs[ei];
          if (e && e.active) {
            // remove edge
            e.active = false;
            if (e.line.line) { e.line.line.material.opacity = 0.05; e.line.line.material.color.set(EDGE_REMOVED); }
            if (e.line.cone) { e.line.cone.material.opacity = 0.05; e.line.cone.material.color.set(EDGE_REMOVED); }
            indeg[e.v] -= 1;
            if (indeg[e.v] === 0) queue.push(e.v);
          }
        }
      }
      processedCount += 1;
      document.getElementById('status').textContent = `Status: step ${processedCount} / ${indeg.length}`;

      // preview next node's outgoing edges after updates
      resetHighlightsToBlack();
      if (queue.length) highlightOutgoing(queue[0]);

      if (processedCount >= indeg.length) {
        document.getElementById('status').textContent = 'Status: completed';
        pausePlayback();
      }
    }

    function startPlayback() {
      if (!nodeMap.size) return;
      if (!indeg.length) return;
      const stepMs = Math.max(50, parseInt(document.getElementById('stepMs').value || '800', 10));
      if (playTimer) clearInterval(playTimer);
      playTimer = setInterval(processStep, stepMs);
      document.getElementById('status').textContent = 'Status: playing';
    }

    function pausePlayback() {
      if (playTimer) {
        clearInterval(playTimer);
        playTimer = null;
        document.getElementById('status').textContent = 'Status: paused';
      }
    }

    function resetPlayback() {
      pausePlayback();
      currentStep = 0;
      highlightStep(0, true);
      if (indeg.length && edgeObjs.length && adjIdx.length) {
        buildIndeg(document.lastH || [], document.lastList || []);
      }
      document.getElementById('status').textContent = 'Status: idle';
    }

    window.addEventListener('resize', () => {
      const w = window.innerWidth - CONTROLS_WIDTH;
      const h = window.innerHeight;
      renderer.setSize(w, h);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    });

    function loadLayoutFromInput() {
      const text = document.getElementById('jsonInput').value;
      const obj = JSON.parse(text);
      const layout = obj.layout || obj[0]?.layout || [];
      const h = obj.h || obj[0]?.h || [];
      const list = obj.list || obj[0]?.list || [];
      const topo = obj.topo || obj[0]?.topo || [];
      const randomFlag = obj.random || obj[0]?.random || false;
      edgeJitterEnabled = !!randomFlag;
      document.lastH = h;
      document.lastList = list;
      renderLayout(layout, h, list, topo);
    }

    document.getElementById('loadBtn').onclick = () => {
      try { loadLayoutFromInput(); }
      catch (e) { alert('Invalid JSON: ' + e.message); }
    };

    document.getElementById('startVizBtn').onclick = () => {
      try {
        loadLayoutFromInput();
        startPlayback();
      } catch (e) {
        alert('Invalid JSON: ' + e.message);
      }
    };

    document.getElementById('confirmBtn').onclick = handleConfirmInput;
    document.getElementById('genSmall').onclick = () => { currentSize = 'small'; generateAndFill(document.getElementById('inputType').value); };
    document.getElementById('genMedium').onclick = () => { currentSize = 'medium'; generateAndFill(document.getElementById('inputType').value); };
    document.getElementById('genLarge').onclick = () => { currentSize = 'large'; generateAndFill(document.getElementById('inputType').value); };
    document.getElementById('genEdge').onclick = () => generateAndFill('edge');
    document.getElementById('genCSR').onclick = () => generateAndFill('csr');

    document.getElementById('playBtn').onclick = startPlayback;
    document.getElementById('pauseBtn').onclick = pausePlayback;
    document.getElementById('resetBtn').onclick = resetPlayback;

    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
